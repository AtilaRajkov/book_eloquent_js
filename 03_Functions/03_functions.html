<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Eloquent JavaScript</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>

<h1>03 - Functions</h1>

<ol>
    <li>Defining a Function</li>
    <li>Bindings and Scopes</li>
    <li>Nested Scopes</li>
    <li>Functions as Values</li>
    <li>Arrow Functions</li>
    <li>The Call Stack</li>
    <li>Optional Arguments</li>
    <li>Closure</li>
    <li>Recursion</li>
    <li>Growing Functions</li>
    <li>Functions and Side Effects</li>
</ol>


<script>

        /// DEFINING A FUNCTION ///

    // const square = function(x) {
    //     return x * x;
    // };
    // console.log(square(12));

    // const makeNoise = function() {
    //     console.log("Pling!");
    // };
    // makeNoise();

    // const power = function(base, exponent) {
    //     let result = 1;
    //     for (let count = 0; count < exponent; count++) {
    //         result *= base;
    //     }
    //     return result;
    // };
    // console.log(power(2, 10));



        /// BINDINGS AND SCOPES ///

    // let x = 10;
    // if (true) {
    //     let y = 20;
    //     var z = 30;
    //     console.log(x + y + z); // 60
    // }
    // // y is not visible here
    // console.log(x + z); // 40

    /// Each scope can "look out" into the scope around it, so x is visible inside the
    /// block in the example.

    // const halve = function(n) {
    //     return n / 2;
    // };
    //
    // let n = 10;
    // console.log(halve(100)); // 50
    // console.log(n); // 10



        /// NESTED SCOPES ///

    // const hummus = function(factor) {
    //     const ingredient = function(amount, unit, name) {
    //         let ingredientAmount = amount * factor;
    //         if (ingredientAmount > 1) {
    //             unit += "s";
    //         }
    //         console.log(`${ingredientAmount} ${unit} ${name}`);
    //     };
    //     ingredient(1, "can", "chickpeas");
    //     ingredient(0.25, "cup", "tahini");
    //     ingredient(0.25, "cup", "lemon juice");
    //     ingredient(1, "clove", "garlic");
    //     ingredient(2, "tablespoon", "olive oil");
    //     ingredient(0.5, "teaspoon", "cumin");
    // };
    // hummus(6);

    ///     The set of bindings visible inside a block is determined by the place of that
    /// block in the program text. Each local scope can also see all the local scopes that
    /// contain it, and all scopes can see the global scope. This approach to binding
    /// visibility as called "LEXICAL SCOPING".



        /// FUNCTIONS AS VALUES ///

    // let launchMissiles = function() {
    //     missileSystem.launch("now");
    // };
    // if (safeMode) {
    //     launchMissiles = function() { /* do nothing */ };

    // }



        /// DECLARATION NOTATION ///

    /// Function Declaration:

    // function square(x) {
    //     return x * x;
    // }

    // console.log("The future says: ", future());
    // function future() {
    //     return "You'll never have flying cars."
    // }



        /// ARROW FUNCTIONS ///

    // const power = (base, exponent) => {
    //     let result = 1;
    //     for (let count = 0; count < exponent; count++) {
    //         result *= base;
    //     }
    //     return result;
    // };
    // console.log(power(3, 3));
    //
    // const square1 = (x) => { return x * x };
    // const square2 = (x) => x * x;
    //
    // const horn = () => {
    //     console.log("Tooth");
    // };



        /// THE CALL STACK ///

    // function chicken() {
    //     return egg();
    // }
    // function egg() {
    //     return chicken();
    // }
    // console.log(chicken() + " came first.");



        /// OPTIONAL ARGUMENTS ///

    // function square(x) { return x * x }
    // console.log(square(4, true, "hedgehog"));

    // function minus(a, b) {
    //     if (b === undefined) return -a;
    //     else return a - b;
    // }
    // console.log(minus(10));  // -10
    // console.log(minus(10, 5)); // 5

    // function power(base, exponent = 2) {
    //     let result = 1;
    //     for (let count = 0; count < exponent; count++) {
    //         result *= base;
    //     }
    //     return result;
    // }
    //
    // console.log(power(4));  // 15
    // console.log(power(2, 6)); // 64

    // console.log("C", "0", 2);



        /// CLOSURE ///

    // function wrapValue(n) {
    //     let local = n;
    //     return () => local;
    // }
    //
    // function wrapValue(n) {
    //     let local = n;
    //     return function() { return local; }
    // }
    //
    // let wrap1 = wrapValue(1);
    // let wrap2 = wrapValue(2);
    // console.log(wrap1());  // 1
    // console.log(wrap2());  // 2
    // console.log(wrapValue(3)());  // 3


    // /// function that multiply by an arbitrary amount.
    // function multiplier(factor) {
    //     return number => number * factor;
    // }
    //
    // // is it same as???
    // function multiplierMy(factor) {
    //     return (number) => number * factor;
    // }
    //
    // let twice = multiplier(2);
    // console.log(twice(5));   // 10
    //
    // let twiceMy = multiplierMy(2);
    // console.log(twiceMy(5));  // 10



        /// RECURSION ///
    //
    // function power(base, exponent) {
    //     if (exponent == 0) {
    //         return 1;
    //     } else {
    //         return base * power(base, exponent - 1);
    //     }
    // }
    // console.log(power(2, 3)); // 8


    /// By starting from the number 1 and repeatedly either adding 5 or multiplying by 3
    /// an infinite set of number can be produced.

    // function findSolution(target) {
    //     function find(current, history) {
    //         if (current == target) {
    //             return history;
    //         } else if (current > target) {
    //             return null;
    //         } else {
    //             return find(current + 5, `(${history} + 5)`) ||
    //                    find(current * 3, `(${history} * 3)`);
    //         }
    //     }
    //     return find(1, "1");
    // }
    // console.log(findSolution(18));



        /// GROWING FUNCTIONS ///

    // function printFarmInventory(cows, chickens) {
    //     let cowString = String(cows);
    //     while (cowString.length < 3) {
    //         cowString = "0" + cowString;
    //     }
    //     console.log(cowString);
    //     let chickenString = String(chickens);
    //     while (chickenString.length < 3) {
    //         chickenString = "0" + chickenString;
    //     }
    //     console.log(chickenString);
    // }
    // printFarmInventory(7, 11);


    // function printZeroPaddedWithLabel(number , label) {
    //     let numberString = String(number);
    //     while (numberString.length < 3) {
    //         numberString = "0" + numberString;
    //     }
    //     console.log(`${numberString} ${label}`);
    // }
    // function printFromInventory(cows, chickens, pigs) {
    //     printZeroPaddedWithLabel(cows, "Cows");
    //     printZeroPaddedWithLabel(chickens, "Chickens");
    //     printZeroPaddedWithLabel(pigs, "Pigs");
    // }
    // console.log(printFromInventory(7, 11, 3));


    // function zeroPad(number, width) {
    //     let string = String(number);
    //     while (string.length < width) {
    //         string = "0" + string;
    //     }
    //     return string;
    // }
    //
    // function printFarmInventory(cows, chickens, pigs) {
    //     console.log(`${zeroPad(cows, 3)} Cows`);
    //     console.log(`${zeroPad(chickens, 3)} Chickens`);
    //     console.log(`${zeroPad(pigs, 3)} Pigs`);
    // }
    //
    // printFarmInventory(7, 16, 3);



    /// FUNCTIONS AND SIDE EFFECTS ///




</script>

</body>
</html>